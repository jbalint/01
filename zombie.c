/*
 * $Id: zombie.c 2 2007-07-26 03:52:55Z jbalint $
 * Zombie: A Game
 *
 * A small, fun game to play when bored. Upon running, several zombies will appear
 * to dance around the screen. Each corresponds to an actual zombie process
 * generated by the game. You must reap all the zombies to win. This is done by
 * typing the letter on the sides of each zombie (drawn in yellow). Zombies will
 * spawn quickly so you must be sharp and fast to win. Good luck!
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <curses.h>
#include <signal.h>
#include <assert.h>
#include <sys/time.h>
#include <sys/poll.h>

/*
 * watch -n 1 "ps -ef | grep -i defunct | grep -v cscope | grep -v grep"
 * cc -Wall -ggdb3 -o zOmBiE zombie.c -lcurses && ./zOmBiE
 */

/*
 * http://web.cs.mun.ca/~rod/ncurses/ncurses.html
 */

/* zombie struct */
typedef struct l_l {
	struct l_l *n;
	pid_t pid;
	int ttm; /* time 'til move */
	int x; /* coords */
	int y;
	char i; /* display char */
	char b[20]; /* display string */
	int bl; /* b[] length */
} list;

static char *acs = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()_+`-=1234567890[]\\';/.,?><:\"{}|";
static int acsl;

static struct pollfd infd;
static struct itimerval itimerval;

static int redraw = 0;
#define COUNTSTOADD 10 /* number of counts before adding a new zombie */
#define COUNTSTOMOVE 6 /* number of counts before a zombie moves */
static int countsleft = COUNTSTOADD;
static list *zs = NULL; /* list of zombies */
static const int boff = 10;

/* called by timer to indicate redraw */
void update(int x __attribute__((unused)))
{
	redraw = 1;
}

void randcoords(int *x, int *y)
{
	*x = rand() % (curscr->_maxx - 10);
	*y = rand() % (curscr->_maxy - 00);
}

void randid(char *c)
{
	*c = acs[rand() % acsl];
}

void drawt()
{
	int i;
	attron(COLOR_PAIR(COLOR_RED));
	for(i = 0; i < 3; ++i)
	{
		addch('~');
	}
	attroff(COLOR_PAIR(COLOR_RED));
}

void drawc(char c)
{
	attron(COLOR_PAIR(COLOR_YELLOW));
	addch(c);
	attroff(COLOR_PAIR(COLOR_YELLOW));
}

void clearz(list *z)
{
	int i;
	move(z->y, z->x);
	for(i = 0; i < z->bl + boff; ++i)
	{
		addch(' ');
	}
}

/* add a new zombie at a randomly chosen location */
void newz()
{
	list *z = malloc(sizeof(list));
	z->n = NULL;
	if(zs)
		z->n = zs;
	randcoords(&z->x, &z->y);
	randid(&z->i);
	z->ttm = COUNTSTOMOVE;
	if(!(z->pid = fork()))
		exit(0);
	zs = z;
	sprintf(z->b, "%d", z->pid);
	z->bl = strlen(z->b);
}

int main(int argc, char **argv)
{
	int blah = 5; /* initial number of zombies */
	initscr();
	keypad(stdscr, TRUE);
	nonl();
	cbreak();
	noecho();

	acsl = strlen(acs);

	srand(time(0));

	start_color();
	init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
	init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
	init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);

	/* init some zombies */
	while(blah-- > 0)
	{
		newz();
	}

	infd.fd = 0;
	infd.events = POLLIN;

	/* set up timer */
	assert(signal(SIGALRM, update) != SIG_ERR);

	itimerval.it_value.tv_sec = 0;
	itimerval.it_value.tv_usec = 500;
	itimerval.it_interval.tv_sec = 0;
	itimerval.it_interval.tv_usec = 100000;

	assert(!setitimer(ITIMER_REAL, &itimerval, NULL));

	/* main loop */
	while(1)
	{
		list *z;

		poll(&infd, 1, 1000);
		if(infd.revents)
		{
			list *p;
			char c;
			/* read the typed letter */
			assert(read(0, &c, 1) == 1);

			/* check if it's one of the zombies */
			p = z = zs;
			while(z)
			{
				/* if it is reap the zombie process and remove it from the list */
				if(z->i == c)
				{
					int i;

					waitpid(z->pid, &i, 0);

					clearz(z);
					if(z == zs)
						zs = z->n;
					else
						p->n = z->n;
					free(z);
					break;
				}
				p = z;
				z = z->n;
			}

			if(!zs) /* zombie list is empty */
			{
				endwin();
				printf("YOU WON!!!!!!!!!!!\n");
				exit(1);
			}
		}

		if(redraw)
		{
			z = zs;
			while(z)
			{
				int i;

				clearz(z);

				move(z->y, z->x);

				/* move zombie, if it's been there long enough */
				if(--z->ttm == 0)
				{
					randcoords(&z->x, &z->y);
					move(z->y, z->x);
					z->ttm = COUNTSTOMOVE;
				}

				drawc(z->i);
				drawt();

				attron(COLOR_PAIR(COLOR_GREEN));
				for(i = 0; i < z->bl; ++i)
				{
					addch(z->b[i]);
				}
				attroff(COLOR_PAIR(COLOR_GREEN));

				drawt();
				drawc(z->i);

				z = z->n;
			}

			/* spawn a new zombie if it's time */
			if(countsleft-- == 0)
			{
				newz();
				countsleft = COUNTSTOADD;
			}

			redraw = 0;
		}

		move(curscr->_maxy, curscr->_maxx);
		refresh();
	}

	endwin();

	return 0;
}

